@inject IMapper mapper
@inject IUIService uiService
@inject IUIManager uiManager
@inject ITaskApiService taskApiService
@inject IResourceHandler resourceHandler
@inject Blazored.Toast.Services.IToastService toastService

<CascadingValue Value="Operation">
	<Modal @ref="@Modal" @bind-Visible="isModalVisible" Closing="@(async (e) => await OnModalClosing(e))" Class="modal-dialog-wide" Border="Border.Rounded">
		@if (isModalVisible)
		{
			@if (TaskMetadata.InitializationInProgres)
			{
				<BackgroundLoadSpinner Class="bg-custom-primary text-custom-primary background-load-spinner-overlay" TextSize="TextSize.Large" />
			}

			<ModalContent Centered Shadow="Shadow.Small">
				@if (isTaskLoading)
				{
					<ContentLoadSpinner />
				}
				else
				{
					<CascadingValue Value="Task">
						<CascadingValue Value="TaskMetadata">
							<CascadingValue Value="Modal">

								<GenericModalHeader DisplayText="@($"{resourceHandler.GetResource($"{UIConstants.Base}.{UIConstants.Generic}.{UIActionConstants.Save}")}{(string.IsNullOrWhiteSpace(Task.Config?.Name) ? string.Empty : $" - {Task.Config.Name}")}")" />

								<ModalBody Padding="Padding.Is0" Class="bg-custom-primary text-custom-primary">
									<Container Fluid>
										<Row>
											<Column ColumnSize="ColumnSize.IsFull">
												<Validations @ref="Validations"
															 Mode="ValidationMode.Auto"
															 ValidateOnLoad="false"
															 EditContext="EditContext"
															 HandlerType="ValidationHandlerType.DataAnnotation">
													<CascadingValue Value="EditContext">
														<CascadingValue Value="Validations">
															<Form Margin="Margin.Is1.FromTop.Is3.FromBottom" Class="text-form-size" Padding="Padding.Is3">
																<TaskSubitemsDataFormSection />
															</Form>
														</CascadingValue>
													</CascadingValue>
												</Validations>
											</Column>
										</Row>

									</Container>
								</ModalBody>

								<TaskEditModalFooter Validations="Validations" @ref="@TaskEditModalFooter" />

							</CascadingValue>
						</CascadingValue>
					</CascadingValue>
				}
			</ModalContent>
		}
	</Modal>
</CascadingValue>

@code {
	[CascadingParameter]
	public ObservableCollection<TaskInfoDto> Tasks { get; set; } = null!;

	[CascadingParameter]
	public TaskInfoDto TaskInfo { get; set; } = new();

	[Parameter]
	public DataOperation Operation { get; set; }

	private bool isTaskLoading = false;
	private bool isModalVisible = false;
	private CancellationTokenSource? cancellationTokenSource;

	private TaskDto Task;
	private TaskViewMetadataDto TaskMetadata;

	private Modal Modal;
	private TaskEditModalFooter TaskEditModalFooter = new();
	private Validations Validations;
	private EditContext? EditContext;

	public TaskEditModal()
	{
		Task = new();
		TaskMetadata = new();

		Modal = new Modal();
		Validations = new Validations();
	}

	private async Task ResetCancellationToken()
	{
		if (cancellationTokenSource is not null)
		{
			await cancellationTokenSource.CancelAsync();
			cancellationTokenSource.Dispose();
		}
		cancellationTokenSource = new();
	}

	private async Task OnModalClosing(ModalClosingEventArgs e)
	{
		e.Cancel = e.CloseReason != CloseReason.UserClosing;
		if (!e.Cancel)
		{
			isModalVisible = false;
			await ResetCancellationToken();
		}
	}

	protected override async Task OnInitializedAsync()
	{
		EditContext = new EditContext(Task);
		EditContext.OnFieldChanged += OnFieldChanged;
		await base.OnInitializedAsync();
	}

	private async void OnFieldChanged(object? sender, FieldChangedEventArgs e)
	{
		var evaluationNeeded = TaskViewMetadataDto.OptionsReloadNecessary(e.FieldIdentifier.FieldName);
		if (evaluationNeeded)
		{
			TaskMetadata.InitializationInProgres = true;
			await ResetCancellationToken();

			try
			{
				var token = cancellationTokenSource!.Token;
				await System.Threading.Tasks.Task.Run(async () =>
				{
					if (!token.IsCancellationRequested)
					{
						await uiService.CallRequestRefreshAsync();

						var updated = await taskApiService.RefreshTaskOptions(Task.ID, Task);
						if (updated is not null && !token.IsCancellationRequested)
						{
							mapper.Map(updated, Task);
						}
					}

				}, token);
			}
			catch (TaskCanceledException)
			{ }
			finally
			{
				TaskMetadata.InitializationInProgres = false;
				await uiService.CallRequestRefreshAsync();
			}
		}
	}

	private Task ShowModal()
	{
		isModalVisible = true;
		return Modal.Show();
	}

	public async Task Show()
	{
		isTaskLoading = true;
		await ResetCancellationToken();
		await ShowModal();

		if (Operation == DataOperation.INSERT)
		{
			var inserted = await taskApiService.InsertTask();
			if (inserted is not null)
			{
				mapper.Map(inserted, Task);
				TaskInfo = mapper.Map<TaskInfoDto>(inserted);
			}
		}
		else
		{
			var opened = await taskApiService.LoadTask(TaskInfo.ID, false);
			if (opened is not null)
			{
				mapper.Map(opened, Task);
			}
		}

		isTaskLoading = false;
		await uiService.CallRequestRefreshAsync();
	}
}